# 동적 계획법(Dynamic Programming)

동적 계획법을 듣기전에 [재귀와 메모이제이션에 대한 이해](https://github.com/BAEKJungHo/algorithms/tree/master/contents/DataStructures/Stack/Recursive#%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98memoization)가 먼저 필요하다. 해당 링크를 통해서 배우고 오자.

메모리 공간을 약간 더 사용해서 연산 속도를 비약적으로 증가시키는 방법이 있는데 대표적인 방법에 `동적 계획법(Dynamic Programming)`이 있다. 다이나믹 프로그래밍 방식은 `TopDown` and `BottomUp` 두 가지가 있으며 메모이제이션 기법을 자주 사용한다.

> 메모이제이션은 동적 계획법을 이용하여 문제를 해결하기 위해 사용되는 방식 중 하나이다.

다이나믹 프로그래밍으로 해결할 수있는 대표적인 예시가 `피보나치 수열`이다. 재귀에서 배웠듯이 재귀를 사용하려면 점화식을 작성해보는 것이 좋다. 피보나치 수열에 대한 점화식은 다음과 같다.

- __피보나치 수열 점화식__
  - n 이 1이거나 2일때 : 1
  - n 이 2보다 클 때 : f(n) = f(n-2) + f(n-1)

프로그래밍에서는 `수열`을 `배열`이나 `리스트`에 저장할 수 있다. 수열 자체가 여러 개의 수가 규칙에 따라서 배열된 형태를 의미하는 것이기 때문이다.

피보나치 수열 같은 경우는 n 의 값이 커질 때마다 그래프의 노드가 기하급수적으로 증가하기 때문에 단순 재귀로 구현하면 안된다라는 것을 위 링크에서 느꼈을 것이다.
이러한 문제에 다이나믹 프로그래밍을 적용하면 효율적으로 해결할 수 있다. 다이나믹 프로그래밍은 다음 조건을 만족할 때 사용할 수 있다.

- 큰 문제를 작은 문제로 나눌 수 있다.
- 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

정리하자면 다이나믹 프로그래밍은 __큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘이다.__

## Top-down 방식 : 메모이제이션

Top-down 방식은 큰 문제를 해결하기 위해 작은 문제를 호출한다고하여 붙여진 이름이다.

다이나믹 프로그래밍은 일반적으로 반복문을 이용하여 구현하는 것이 더 성능이 좋다. 다이나믹 프로그래밍을 적용했을 때의 피보나치 수열 알고리즘의 시간 복잡도는 `O(N)` 이다. 왜냐하면 f(1)을 구한 다음 그 값이 f(2)를 푸는데 사용되고, f(2)를 구한 값은 f(3)을 푸는데 사용된다. 즉, 한 번 구한 결과는 다시 구해지지 않는다.

## Bottom-Up 방식 : 반복문

Bottom-Up 방식은 작은 문제부터 차근차근 답을 도출한다고하여 붙여진 이름이다.

```java
public class annmj.thisiscodingtest.part03.Q07_luckyStraight.Main {

    public static long[] d = new long[100];

    public static void main(String[] args) {
        // 첫 번째 피보나치 수와 두 번째 피보나치 수는 1
        d[1] = 1;
        d[2] = 1;
        int n = 50; // 50번째 피보나치 수를 계산

        // 피보나치 함수(Fibonacci Function) 반복문으로 구현(Bottom-Up 다이나믹 프로그래밍)
        for (int i = 3; i <= n; i++) {
            d[i] = d[i - 1] + d[i - 2];
        }
        System.out.println(d[n]);
    }
}
```

다이나믹 프로그래밍의 전형적인 형태는 `Bottom-Up` 방식이다. Bottom-Up 방식에서 사용되는 결과 저장용 리스트는 `DP 테이블`이라고 부르며, 메모이제이션은 `Top-down` 방식에 국한되어 사용되는 표현이다. 책에서는 가급적 Top-down 방식보다는 Bottom-Up 방식을 사용하여 구현하는것을 추천하고 있다.

- __Bottom-Up 특징__
  - 반복문을 사용
  - DP 테이블을 사용
  - 재귀식을 뽑아낼 수 있으면 재귀식 만들기

## DP 테이블

DP 테이블이 `결과 저장용 리스트`라고 했다. 더 쉽게 이해하기 위해 예제를 들어 설명하겠다. 문제는 "책 이것이 코딩테스트다 217p 의 1로 만들기" 이다. 백준의 1로 만들기 문제와 거의 똑같다.

- __문제__
  - 정수 X 에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.
  - X 가 5로 나누어 떨어지면, 5로 나눈다.
  - X 가 3으로 나누어 떨어지면, 3으로 나눈다.
  - X 가 2로 나누어 떨어지면, 2로 나눈다.
  - X 에서 1을 뺀다.
  - 위의 4개의 연산을 적절히 사용해서 1을 만들려고한다. 연산을 사용하는 횟수의 최솟값을 구하라.
- __입력__
  - `1 <= X <= 30000`
- __출력__
  - 연산을 사용하는 횟수의 최솟값 출력

여기서 DP 테이블은 `연산을 사용하는 횟수의 최솟값(문제에서 원하는 결과)을 저장하는 리스트`라고 생각하면 된다.

- __풀이 방법__
  - 초기 값을 정한다.
    - 경우에 따라서 생략해도 상관 없다.
  - 점화식을 세운다.
    - 점화식을 세울때, 문제를 그래프로 표현하거나 머릿속으로 그래프를 그려보자. 만약 그래프가 안 떠오르면 피보나치수열 그래프를 떠올리자.
    - 다이나믹 프로그래밍의 핵심은 어쨋든 이전에 계산한 결과값을 재사용하는 것이다.
    - 즉, N = 15 이고 최솟값을 구하라고하면 1 부터 15 까지 반복문을 돈다 생각하자. 5를 계산할 차례이면 5는 전에 계산된 4를 재활용할 가능성이 매우 높다.
    - 따라서, 되게 복잡하게 나오지 않는 이상 점화식은 F(N) = MIN(F(N-1), F(N-2)) 범위 내에서 끝날 것 같다.
  - 코드로 구현한다.
    - 이 과정에서 초기 값 설정한 부분이 필요 없을 수 있다. 그때 초기 값을 설정하는 코드를 지우면 된다.
  - `개인적인 생각`
    - 책 몇 문제를 풀어봤는데, 구현해야하는 코드의 양은 적은데, 점화식을 생각하는게 생각보다 어려웠다. 책의 문제를 분석해본결과 보통 1, 2 길면 3까지는 초기값으로 쓰는것 같고, 점화식을 구하기 위해서 그냥 3이상의 숫자를 하나 선정해서 구하는 것 같다. 점화식을 구하려고 너무 큰 숫자를 선정하거나 너무 깊게 생각하다보면 문제를 못풀 것 같다.
    - 문제에서 ~최솟값, ~최댓값을 구하라고하는 다이나믹 프로그래밍 문제는 `Math.min or Math.max` 를 사용하는 것 같다.
      - min, max 함수는 점화식 자체에 들어가는 경우가 많은 것 같다.

```java
/**
 * 동적 계획법이고 최대한 Bottom-Up 방식을 사용해서 해결하기
 * 핵심은 저장된 결과를 재사용
 */
public class annmj.thisiscodingtest.part03.Q07_luckyStraight.Main {

    private static int x;
    private static int[] dp = new int[30001]; // dp[number] 는 number 에 해당하는 숫자가 1이 되기 위해 연산을 사용하는 횟수의 최솟값을 의미한다.

    // 1. 초기 값 정하기 : 현재 이 문제 풀이에서는 static 블럭을 날려도 된다.
    static {
        dp[1] = 0; // 재귀로 구현한다고 했을때는 1이 종료조건임 따라서 연산 횟수는 0번
        dp[2] = 1; // 2는 연산 1번 수행 1을 빼거나 2로 나누거나 둘 중 하나
    }

    public static void main(String[] args) {
        input();
        solution();
        System.out.println(dp[x]);
    }

    private static void input() {
        Scanner sc = new Scanner(System.in);
        x = sc.nextInt();
    }

    // 2. 점화식 세우기 : DP[i] = min(DP[i-1] + 1, DP[i/2] + 1, DP[i/3] + 1 DP[i/5] + 1) (여기의 1은 연산 횟수 증가를 의미)
    private static void solution() {
        for (int i = 2; i <= x; i++) {
            dp[i] = dp[i-1] + 1;
            if (i % 5 == 0) {
                dp[i] = Math.min(dp[i], dp[i / 5] + 1);
            }
            if (i % 3 == 0) {
                dp[i] = Math.min(dp[i], dp[i / 3] + 1);
            }
            if (i % 2 == 0) {
                dp[i] = Math.min(dp[i], dp[i / 2] + 1);
            }
        }
    }
}
```
